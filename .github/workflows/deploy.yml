name: Deploy to GCP VM (via Docker Hub)

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-push:
    name: 1. Build & Push to Docker Hub
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: brillioafrica/api:latest
          cache-from: type=registry,ref=brillioafrica/api:buildcache
          cache-to: type=registry,ref=brillioafrica/api:buildcache,mode=max

  health-check-and-backup:
    name: 2. Pre-deployment Checks & Backup
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
            ssh-private-key: ${{ secrets.GCP_VM_SSH_KEY }}

      - name: Add known hosts
        run: |
          mkdir -p ~/.ssh
          echo "Scanning host: ${{ secrets.GCP_VM_IP }}"
          ssh-keyscan -H -t rsa,ed25519 ${{ secrets.GCP_VM_IP }} >> ~/.ssh/known_hosts || true

      - name: Run Integrity Checks & Backups
        run: |
          ssh ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} << 'ENDSSH'
            set -e # Stop on first error
            
            echo "üîç STARTING PRE-DEPLOYMENT CHECKS..."
            cd /opt/brillio-api || { echo "‚ùå Project directory not found"; exit 1; }

            # 1. Check Docker Accessibility
            if ! docker info > /dev/null 2>&1; then
                echo "‚ùå Docker is not running or not accessible by user!"
                exit 1
            fi
            echo "‚úÖ Docker is running."

            # 2. Check Container Access (if stack is running)
            if [ -f docker-compose.yml ] && docker-compose ps | grep -q "Up"; then
                 echo "üîÑ Stack is running. Testing container access..."
                 
                 # Test App Container
                 if docker-compose exec -T app php -v > /dev/null; then
                    echo "‚úÖ App container is accessible."
                 else
                    echo "‚ùå Failed to access App container command line!"
                    exit 1
                 fi
            else
                 echo "‚ö†Ô∏è Stack not running or fresh install. Skipping container checks."
            fi

            # 3. Perform Backups
            echo "üì¶ STARTING BACKUPS..."
            mkdir -p backups
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)

            # Backup .env
            if [ -f .env ]; then
                cp .env "backups/.env.backup.$TIMESTAMP"
                echo "‚úÖ .env file backed up: backups/.env.backup.$TIMESTAMP"
            else
                echo "‚ö†Ô∏è No .env file found!"
            fi

            # Backup Database
            if [ -f .env ]; then
                # Safe grep extraction (basic)
                DB_USER=$(grep "^DB_USERNAME=" .env | cut -d '=' -f2-)
                DB_PASS=$(grep "^DB_PASSWORD=" .env | cut -d '=' -f2-)
                DB_NAME=$(grep "^DB_DATABASE=" .env | cut -d '=' -f2-)

                if [ -n "$DB_NAME" ]; then
                     echo "üíæ Backing up database '$DB_NAME'..."
                     # Assumes service name is 'mysql'
                     if docker-compose exec -T mysql mysqldump -u"$DB_USER" -p"$DB_PASS" "$DB_NAME" > "backups/db_$TIMESTAMP.sql"; then
                        echo "‚úÖ Database backup created: backups/db_$TIMESTAMP.sql"
                     else
                        echo "‚ùå Database backup FAILED! Check credentials or connection."
                        exit 1
                     fi
                else
                     echo "‚ö†Ô∏è DB_DATABASE not found in .env. Skipping DB backup."
                fi
            fi

            echo "‚úÖ ALL CHECKS & BACKUPS PASSED. Ready for deployment."
          ENDSSH

  deploy:
    name: 3. Deploy to VM
    needs: health-check-and-backup
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
            ssh-private-key: ${{ secrets.GCP_VM_SSH_KEY }}

      - name: Add known hosts
        run: |
          mkdir -p ~/.ssh
          echo "Scanning host: ${{ secrets.GCP_VM_IP }}"
          ssh-keyscan -H -t rsa,ed25519 ${{ secrets.GCP_VM_IP }} >> ~/.ssh/known_hosts || true

      - name: Copy docker-compose and config files
        run: |
          rsync -avz --delete --no-owner --no-group --no-perms --no-times \
            --exclude '.git' \
            --exclude 'node_modules' \
            --exclude 'vendor' \
            --exclude 'docker/certbot' \
            --exclude 'storage' \
            --exclude '.env' \
            ./ ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }}:/opt/brillio-api/

      - name: Deploy on VM
        run: |
          ssh ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} << 'ENDSSH'
            cd /opt/brillio-api
            
            # Login to Docker Hub on VM (for private repo possibility)
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            
            # Ensure DB_HOST is set to mysql in .env
            if grep -q "DB_HOST=" .env; then
              sed -i 's/^DB_HOST=.*/DB_HOST=mysql/' .env
            else
              echo "DB_HOST=mysql" >> .env
            fi

            # Configure Moneroo Production Keys
            echo "üîê Configuring Moneroo payment gateway..."
            
            # Remove any existing Moneroo config
            sed -i '/^MONEROO_/d' .env
            
            # Add production Moneroo config
            echo "" >> .env
            echo "# Moneroo Payment Gateway (Production)" >> .env
            echo "MONEROO_SECRET_KEY=${{ secrets.MONEROO_LIVE_KEY }}" >> .env
            echo "MONEROO_SANDBOX=false" >> .env
            echo "MONEROO_WEBHOOK_SECRET=${{ secrets.MONEROO_WEBHOOK_SECRET }}" >> .env
            echo "MONEROO_CURRENCY=XOF" >> .env
            echo "MONEROO_API_URL=https://api.moneroo.io/v1" >> .env
            
            echo "‚úÖ Moneroo production keys configured"

            # Configure Jitsi (JAAS) Keys
            echo "üîê Configuring Jitsi (JAAS) keys..."
            
            # Remove any existing JAAS config
            sed -i '/^JAAS_/d' .env
            
            # Decode base64 JAAS_PRIVATE_KEY and escape newlines for .env
            JAAS_KEY=$(echo '${{ secrets.JAAS_PRIVATE_KEY }}' | base64 -d | awk '{printf "%s\\n", $0}' | sed '$ s/\\n$//')
            
            # Add JAAS config from secrets
            echo "" >> .env
            echo "# Jitsi (JAAS) Configuration" >> .env
            echo "JAAS_APP_ID=${{ secrets.JAAS_APP_ID }}" >> .env
            echo "JAAS_KEY_ID=${{ secrets.JAAS_KEY_ID }}" >> .env
            echo "JAAS_PRIVATE_KEY=\"$JAAS_KEY\"" >> .env
            
            echo "‚úÖ Jitsi (JAAS) keys configured"

            # Validate .env syntax before proceeding
            echo "üîç Validating .env syntax..."
            if docker run --rm -v /opt/brillio-api/.env:/tmp/.env php:8.2-cli php -r 'parse_ini_file("/tmp/.env", false, INI_SCANNER_RAW);' 2>/dev/null; then
                echo "‚úÖ .env syntax is valid"
            else
                echo "‚ùå ERROR: .env syntax is INVALID! Deployment aborted."
                echo "üìã Last 10 lines of .env for debugging:"
                tail -10 .env
                exit 1
            fi

            # Pull latest image
            docker-compose pull app
            
            # Restart containers with new image
            docker-compose up -d --remove-orphans
            
            # Wait for MySQL (just in case it restarted)
            echo "Waiting 30s for MySQL to initialize..."
            sleep 30
            
            # Run migrations
            docker-compose exec -T app php artisan migrate --force
            
            # Optimize Laravel
            docker-compose exec -T app php artisan config:cache
            docker-compose exec -T app php artisan route:cache
            docker-compose exec -T app php artisan view:cache
            
            # Cleanup old images
            docker image prune -f
            
            echo "‚úÖ D√©ploiement via Docker Hub termin√© avec succ√®s"
          ENDSSH